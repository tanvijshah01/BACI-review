---
title: "Wauchope_1_CollateCleanRawData_TS"
format: html
editor: visual
author: Tanvi Shah
date: 7/14/25
---

## Load Libraries

```{r}
library(here)
library(janitor)
library(tidyverse)
library(sp)
library(readxl)
# library(rgdal) - no longer exists
library(ggplot2)
library(raster)
library(data.table)
library(pbmcapply)
library(reshape2)
# library(rgeos) - no longer exists
library(plyr)
library(ncdf4)
library(pbapply)
library(maps)
# library(ggalt)
library(taxize)
library(stringr)
library(rredlist)
library(dplyr)
```

## Read data

```{r}

data_filename = '20250723_TanviShah_CBC_Circle_Species_Report.csv'
effort_filename = '20250723_TanviShah_CBC_Effort_Many_Types_Report.csv'

# get current directory, make sure project is open 
baci_home_dir <-here::here()
# navigate to data directory
curr_data_path <- file.path(baci_home_dir, 'data~')

```

```{r}

cbc_data <- read_csv(file.path(curr_data_path, 'raw_data','Wauchope','TanviShah_CBC_Data_Request', data_filename))

effort_data <- read_csv(file.path(curr_data_path,'raw_data','Wauchope', 'TanviShah_CBC_Data_Request', effort_filename)) %>% clean_names()

AviList <- read_excel(file.path(curr_data_path,"raw_data", "Wauchope", "AviList-v2025.xlsx")) %>% clean_names()

```

## Initial Clean

```{r}

# CBC Initial Clean
CBCCounts <- cbc_data
names(CBCCounts) <- c("OID", "Abbrev", "Name", "Latitude", "Longitude", "Subnational_code", "Country_code", "Count_yr", "Cnt_dt", "COM_NAME", "SCI_NAME", "how_many", "TotalSpecies", "Editor_comment")

CBCCounts$Abbrev <- gsub('"', '', as.character(CBCCounts$Abbrev))
CBCCounts$Subnational_code <- gsub('"', '', as.character(CBCCounts$Subnational_code))
CBCCounts$Country_code <- gsub('"', '', as.character(CBCCounts$Country_code))
CBCCounts$Cnt_dt <- gsub('"', '', as.character(CBCCounts$Cnt_dt))
CBCCounts$COM_NAME <- gsub('"', '', as.character(CBCCounts$COM_NAME))
CBCCounts$Name <- gsub('"', '', as.character(CBCCounts$Name))
CBCCounts$SCI_NAME <- gsub('"', '', as.character(CBCCounts$SCI_NAME))

```

## Taxonomic Filtering

#### TS approach (CBC data only):

1\) Filter AviList for waterbird families of interest (stated in p. 3 of [Wauchope SI](https://static-content.springer.com/esm/art%3A10.1038%2Fs41586-022-04617-0/MediaObjects/41586_2022_4617_MOESM1_ESM.pdf))

2\) Eliminate entries with "sp."

3\) Save the exact matches

4\) Filter the edge cases, and save to master list

5\) Aggregate disctinct entries given same genus species (and time, location)

TS - What is OID? maybe agg based on this

```{r}

# waterbird families of interest
# directly from p. 3 of Wauchope SI
waterbird_families <- c(
  "Gaviidae", "Podicipedidae", "Pelecanidae", "Phalacrocoracidae", "Anhingidae",
  "Ardeidae", "Balaenicipitidae", "Scopidae", "Ciconiidae", "Threskiornithidae",
  "Phoenicopteridae", "Anhimidae", "Anatidae", "Pedionomidae", "Gruidae",
  "Aramidae", "Rallidae", "Heliornithidae", "Eurypygidae", "Jacanidae",
  "Rostratulidae", "Dromadidae", "Haematopodidae", "Ibidorhynchidae", 
  "Recurvirostridae", "Burhinidae", "Glareolidae", "Charadriidae", 
  "Scolopacidae", "Thinocoridae", "Laridae", "Rynchopidae")

# useful for debugging
alphabetized_waterbird_families <- sort(waterbird_families)
```

Step 1: Filter AviList for Waterbird families of interest

```{r}

avi_f <- AviList %>% filter(family %in% alphabetized_waterbird_families )

matched_families <- intersect(alphabetized_waterbird_families, unique(AviList$family))
unmatched_families <- setdiff(alphabetized_waterbird_families, unique(AviList$family))
cat('Unmatched - Waterbird families that do not match between Avilist and CBC: ', unmatched_families, "\n", "\n")
cat('Matched - Waterbird families in Avilist that match with CBC: ', matched_families, "\n", "\n")

# total waterbird species in AviList
unique_sp_avi <- avi_f %>% filter(taxon_rank == "species")
cat('Number of unique species = ', nrow(unique_sp_avi), "\n","\n")
unique_sub_sp_avi <- avi_f %>% filter(taxon_rank == "subspecies")
cat("Number of unique subspecies = ", nrow(unique_sub_sp_avi))

```

Step 2 - Filter out CBC entries with "sp." -- will not find match to species

```{r}

CBCCounts_no_sp <- CBCCounts %>% filter(!str_detect(SCI_NAME, 'sp.'))
cat(nrow(CBCCounts) - nrow(CBCCounts_f), " rows removed by filtering out sci names with sp.")
```

Step 3 - Keep CBC entries that have an exact genus species (or subspecies) match with waterbirds avilist

```{r}

# save rows with sci name that matches avilist entries exactly 
# of the form: "genus species" and "genus species subspecies"
CBC_exact_match <- CBCCounts_no_sp %>% filter(SCI_NAME %in% unique(avi_f$scientific_name))
```

Step 4 - Deal with edge cases,

```{r}

# Start with set exluded from prior step 
# Everything that doesn't fall under form: genus species and genus species subspecies
# This includes...
  # genus speciesA/speciesB --> exclude
  # genus species subspeciesA/subspeciesB --> include, merge counts under "genus species"
  # genus species [subspecies group] --> include, merge counts under "genus species"

# Separate genus, species, and subspecies
CBC_edge_cases <- CBCCounts_no_sp %>% filter(!SCI_NAME %in% unique(avi_f$scientific_name)) %>% 
  separate(SCI_NAME, into = c("Genus", "Species", "Subspecies"), 
           sep = " ", fill = "right", extra = "drop", remove = FALSE)

# remove indeterminate species (containing slash in species)
CBC_edge_no_ind_species <- CBC_edge_cases %>%  filter(!str_detect(Species, "/"))

# rename indeterminate subspecies to simply "genus species"
# note: this is not very necessary, could also just merge later based on only the first # two words (genus, species)
CBC_edge_filtered <- CBC_edge_no_ind_species %>% mutate(SCI_NAME = str_c(word(SCI_NAME, 1), word(SCI_NAME, 2), sep = " "))


# change exact matches sci name to just genus species
CBC_exact_match_mod <-CBC_exact_match  %>% 
  mutate(SCI_NAME = str_c(word(SCI_NAME, 1), word(SCI_NAME, 2), sep = " "))


CBC_total_match <- bind_rows(CBC_exact_match_mod, CBC_edge_filtered) %>% arrange(SCI_NAME)
```

Step 5 - aggregate entries with same genus, species, date, location (subspecies should be counted under parent genus, species)

```{r}

# waterbirds CBC - 100, 200

# 
# avi_fsp <- avi_f %>% filter(!speciesfamily)

# aggregate
CBC_aggregated <- CBC_total_match %>%
  group_by(Abbrev, Count_yr, SCI_NAME) %>%
  dplyr::summarise(total_count = sum(how_many, na.rm = TRUE))


names(CBC_total_match)       # make sure "how_many" exists
sum(is.na(CBC_total_match$how_many))  # check how many NAs
```

Step 4

```{r}


# another method: 
# assign keep or remove tag to every CBC entry based on meeting or violating criteria
# keep - exact genus species match | keep but aggregate with other subspecies
# remove - includes sp, no species included, 
# could get hairy, good approach to fact check current one


########################################################################

CBCSpecies <- as.data.frame(unique(CBCCounts$SCI_NAME))
names(CBCSpecies) <- "Species"
### combine synonyms here?
## check how many real species are in CBC data

CBCSpecies$FinalName <- apply(CBCSpecies, 1, function (x){
  if(x["Species"] %in% filtered_avi$scientific_name){
    x["Species"]
  } else {"NoMatch"}
})

cat("Number of Matches represents number of CBC Species records that are within the list of families defined by Wauchope", "/n")
cat("**Number of No Matches using AviList = ", nrow(CBCSpecies[CBCSpecies$FinalName == "NoMatch",]), "\n")
cat("**Number of Matches =",nrow(CBCSpecies[!CBCSpecies$FinalName == "NoMatch",]))
# so 400 waterbird species are 
```

### Original HW Code

```{r}

# #### Original HW Code -- Taxonomic Cleaning CBC ####
# 
# CBCSpecies <- as.data.frame(unique(CBCCounts$SCI_NAME))
# names(CBCSpecies) <- "Species"
# 
# # (Q) Unsure where BOTWNames comes from --- "Birds of the World"?

# 
# CBCNoMatch <- subset(CBCSpecies, FinalName=="NoMatch")
# 
# #TreeofLifeID <- pbmclapply(CBCNoMatch$Species, function (x) tryCatch(as.data.frame(get_tolid_(as.character(x))), error=function(e){"NoMatch"}), mc.cores=8)
# #names(TreeofLifeID) <- CBCNoMatch$Species
# #save(TreeofLifeID, file=paste0(DataFP, "WaterbirdData_2020/CBC/TreeofLifeID.RData"))
# #load(file=paste0(DataFP, "WaterbirdData_2020/CBC/TreeofLifeID.RData"))
# 
# SpeciesSynonyms <- TreeofLifeCleaning(TreeofLifeID, CBCNoMatch)
# write.csv(subset(SpeciesSynonyms, FinalName=="NoMatch"), paste0(DataFP, "WaterbirdData_2020/CBC/Cleaning/NoMatchSpecies.csv"), row.names=FALSE)
# 
# #Load up cleaned species
# NameUpdates <- read.csv(paste0(DataFP, "WaterbirdData_2020/CBC/Cleaning/NoMatchSpeciesResearchedCBC.csv"))
# 
# CBCTaxonCleaned <- PostUpdateTaxonCleaning(NameUpdates, SpeciesSynonyms)
# 
# #Now add back into the CBC that was cleaned to begin with:
# names(CBCSpecies) <- c("GivenSpecies", "Species")
# 
# CBCTaxonCleaned <- rbind(subset(CBCSpecies, Species!="NoMatch"), CBCTaxonCleaned, fill=TRUE)
# if(nrow(CBCTaxonCleaned)!=nrow(CBCSpecies)){stop("Somethings gone wrong with synonym matching!")}
# CBCTaxonCleaned[is.na(CBCTaxonCleaned$HybridFlag)]$HybridFlag <- 0
# 
# #Add in higher order taxonomy
# GetSISID <- merge(CBCTaxonCleaned, unique(BOTWNames[,c("SCINAME", "SISRecID")]), by.x="Species", by.y="SCINAME", all.x=TRUE)
# if(nrow(GetSISID) != nrow(CBCTaxonCleaned)){stop("Matching issue!")}
# if(nrow(GetSISID[!is.na(GetSISID$SISRecID),]) != nrow(subset(CBCTaxonCleaned, HybridFlag==0))){stop("Matching issue!")}
# 
# GetSISID2 <- as.data.frame(merge(GetSISID, Tax, by=c("SISRecID", "Species"), all.x=TRUE))
# if(nrow(GetSISID2) != nrow(CBCTaxonCleaned)){stop("Matching issue!")}
# if(nrow(GetSISID2[!is.na(GetSISID2$SISRecID),]) != nrow(subset(CBCTaxonCleaned, HybridFlag==0))){stop("Matching issue!")}
# 
# GetSISID2$Genus <- NA
# GetSISID2[GetSISID2$HybridFlag==0,]$Genus <- str_split_fixed(GetSISID2[GetSISID2$HybridFlag==0,]$Species, "[ ]", 2)[,1]
# 
# ###Higher order matching check###
# HybridGenus <- unique(subset(GetSISID2, HybridLevel=="Genus")$HybridValue)
# HybridGenus <- HybridGenus[!HybridGenus %in% unique(Tax$Genus)]
# 
# HybridFamily <- unique(subset(GetSISID2, HybridLevel=="Family")$HybridValue)
# HybridFamily <- HybridFamily[!HybridFamily %in% unique(Tax$Family)]
# 
# HybridOrder <- unique(subset(GetSISID2, HybridLevel=="Order")$HybridValue)
# HybridOrder <- HybridOrder[!HybridOrder %in% unique(Tax$Order)]
# 
# #Add back to count data
# CBCCounts2 <- merge(GetSISID2, CBCCounts, by.x="GivenSpecies", by.y="SCI_NAME", all=T)
# if(nrow(CBCCounts2)!=nrow(CBCCounts)){stop("Something's gone wrong!")}
# write.csv(CBCCounts2, paste0(DataFP, "WaterbirdData_2020/CBC/CBCCounts_SpeciesCleaned.csv"), row.names = FALSE)
# 
# #### CBC Effort Cleaning + Double Counts ####
# #Read in count data
# CBCCounts <- fread(paste0(DataFP, "WaterbirdData_2020/CBC/CBCCounts_SpeciesCleaned.csv"))

```

## Get Effort

```{r}

#Get Effort
CBCEffort <- effort_data
names(CBCEffort) <- c("OID", "Abbrev", "Name", "Count_yr", "Country_code", "Description", "Distance","Distance_unit", "Hours")



# Effort1_116 <- fread(paste0(DataFP, "WaterbirdData_2020/CBC/RawData/1-116-all-CBC_Effort_Report_2.csv"))
# names(Effort1_116) <- c("Abbrev", "Name", "Count_yr", "Country_code", "Distance", "Hours")
# Effort117_118 <- fread(paste0(DataFP, "WaterbirdData_2020/CBC/RawData/117-118-CBC_Effort_Report_SQL_updated-2.csv"))
# names(Effort117_118) <- c("Abbrev", "Name", "Count_yr", "Country_code", "Method", "Distance", "Units", "Hours")
# CBCEffort <- rbind(Effort1_116, Effort117_118, fill=TRUE)
###

#Distance and hours are correlated - convert to numeric, remove NA's
CBCEffort$Distance <- as.numeric(CBCEffort$Distance)
CBCEffort$Hours <- as.numeric(CBCEffort$Hours)
CBCEffort <- CBCEffort[complete.cases(CBCEffort$Hours),]
CBCEffort <- CBCEffort[complete.cases(CBCEffort$Distance),]

# Quick Bootstrap simulation for visualization
CBCEffortThou <- CBCEffort[sample(1:nrow(CBCEffort), 1000, replace=TRUE),]
plot(CBCEffortThou$Hours, CBCEffortThou$Distance)


#Remove distance and zero count hours
CBCEffort[,c("Distance", "Units", "Method", "Name", "Country_code")] <- NULL
CBCEffort2 <- subset(CBCEffort, Hours!=0)



#Now combine hours

# ------------ HW approaches ----------- delete
# keys <- colnames(CBCEffort)[!colnames(CBCEffort) %in% "Hours"]

 # keys <- setdiff(colnames(CBCEffort), "Hours")
 # CBCEffort2 <- CBCEffort %>%
 #   group_by(across(all_of(keys))) %>%
 #   summarise(Hours = sum(Hours, na.rm= TRUE))

  # CBCEffort2 <- CBCEffort %>%
 #   group_by(across(-Hours)) %>%
 #   summarise(
 #     Hours = sum(Hours, na.rm = TRUE),
 #     OID = first(OID),
 #     Abbrev = first(Abbrev),
 #     Count_yr = first(Count_yr),
 #     Description = first(Description),
 #     Distance_unit = first(Distance_unit),
 #     Hours = first(Hours)
 #   )
 # -------------------------------------------

 CBCEffort2 <- CBCEffort %>%
  group_by(across(-Hours)) %>%
  summarise(Hours = sum(Hours, na.rm = TRUE), .groups = "drop")




Check <- dcast(CBCEffort2, Abbrev + Count_yr~., length, value.var="Hours")
if(max(unique(Check$.))!=1){stop("There are still cases of double hours!")}


CBCCounts$SiteYear <- paste0(CBCCounts$Abbrev,"_", CBCCounts$Count_yr)
CBCCounts_original <- CBCCounts # redundant, keeping for now...
CBCCounts_premerge <- CBCCounts  %>% dplyr::select(-c(OID, Abbrev))

CBCEffort2$SiteYear <- paste0(CBCEffort2$Abbrev,"_", CBCEffort2$Count_yr)
CBCEffort2[,c("Abbrev", "Count_yr")] <- NULL

CBCCounts3 <- merge(CBCCounts_premerge, CBCEffort2, by="SiteYear")
#Now sort out dates
CBCCounts[,c("Year", "Month", "Day")] <- as.data.frame(str_split_fixed(CBCCounts$Cnt_dt, "[-]", 3))
CBCCounts$Month <- as.numeric(as.character(CBCCounts$Month))
CBCCounts[is.na(CBCCounts$Month),]$Month <- 0
CBCCounts <- subset(CBCCounts, Month!=3) #Remove march counts (only Dec, Jan, Feb)

CBCCounts$Year <- 1900+CBCCounts$Count_yr

CBCCounts$Day <- as.numeric(as.character(CBCCounts$Day))
CBCCounts[is.na(CBCCounts$Day),]$Day <- 0

CBCCounts[,c("Count_yr", "Cnt_dt")] <- NULL

#Now sort out double counts (sum by days counted, then mean by year)
CBCCounts$SiteSpecYear <- paste0(CBCCounts$Abbrev, "_", CBCCounts$Species, "_", CBCCounts$Year)
# CBCCountsNoHybrids <- subset(CBCCounts, HybridFlag==0)

#Sum by date
# # NOTE: removing SORT_CBC column compared to original, because doesn't exist in this dataset
# 
# # (Q) - What are hybrids? there's no hybrid flag...
# CBCCountsNoHybrids[,c("COM_NAME", "GivenSpecies", "Editor_comment", "TotalSpecies")] <- NULL
# 
# 
# keys <- colnames(CBCCountsNoHybrids)[!colnames(CBCCountsNoHybrids) %in% "how_many"]
# CBCCountsNoHybrids2 <- CBCCountsNoHybrids[,list(Count=sum(how_many)),keys]
# 
# #Mean by year
# CBCCountsNoHybrids2[,c("Month", "Day")] <- NULL
# 
# keys <- colnames(CBCCountsNoHybrids2)[!colnames(CBCCountsNoHybrids2) %in% "Count"]
# CBCCountsNoHybrids3 <- CBCCountsNoHybrids2[,list(Count=round(mean(Count))),keys]
# 
# #Check
# DoubleCountCheck <- dcast(CBCCountsNoHybrids3, SiteSpecYear~., length, value.var="Count")
# if(max(unique(DoubleCountCheck$.))!=1){stop("There are still double counts!")}
# 
# #Recombine Data
# CBCCountsHybrids <- subset(CBCCounts, HybridFlag==1)
# # NOTE: removing SORT_CBC column compared to original, because doesn't exist in this dataset
# CBCCountsHybrids[,c("COM_NAME", "GivenSpecies", "Editor_comment", "TotalSpecies", "Month", "Day", "how_many")] <- NULL
# CBCCountsHybrids$Count <- NA

# CBCCounts <- rbind(CBCCountsHybrids, CBCCountsNoHybrids3)
CBCCounts[,c("SiteSpecYear", "SiteYear")] <- NULL

#Remove multiple sites at the site coordinate:
CBCCounts$Latitude <- round(CBCCounts$Latitude, 4)
CBCCounts$Longitude <- round(CBCCounts$Longitude, 4)

CBCCounts$Coordinates <- paste0(CBCCounts$Latitude, "_", CBCCounts$Longitude)
CBCCountsCast <- dcast(unique(CBCCounts[,c("Coordinates", "Abbrev")]), Coordinates~., length, value.var="Abbrev")

CBCCounts <- CBCCounts[CBCCounts$Coordinates %in% subset(CBCCountsCast, .==1)$Coordinates,]
CBCCounts$Coordinates <- NULL

#Check on a map
#Map(unique(CBCCounts[,c("Latitude", "Longitude", "Abbrev")]))

# write.csv(CBCCounts, paste0(DataFP, "WaterbirdData_2020/CBC/CBCCounts_SpeciesEffortCleaned.csv"), row.names=FALSE)

write.csv(CBCCounts, file.path(baci_home_dir, "data~", "output", "Wauchope", 'BirdCounts.csv'), row.names = FALSE)



```
