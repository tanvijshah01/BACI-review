---
title: "Wauchope_1_CollateCleanRawData_TS"
format: html
editor: visual
author: Tanvi Shah
date: 7/14/25
---

## Load Libraries

```{r}
library(here)
library(janitor)
library(tidyverse)
library(sp)
library(readxl)
# library(rgdal) - no longer exists
library(ggplot2)
library(raster)
library(data.table)
library(pbmcapply)
library(reshape2)
# library(rgeos) - no longer exists
library(plyr)
library(ncdf4)
library(pbapply)
library(maps)
# library(ggalt) - no longer exists
library(taxize)
library(stringr)
library(rredlist)
library(dplyr)
library(kableExtra)
```

## Read data

```{r}

data_filename = '20250723_TanviShah_CBC_Circle_Species_Report.csv'
effort_filename = '20250723_TanviShah_CBC_Effort_Many_Types_Report.csv'

# get current directory, make sure project is open 
baci_home_dir <-here::here()
# navigate to data directory
curr_data_path <- file.path(baci_home_dir, 'data')


cbc_data <- read_csv(file.path(curr_data_path, 'raw_data','Wauchope','TanviShah_CBC_Data_Request', data_filename))

effort_data <- read_csv(file.path(curr_data_path,'raw_data','Wauchope', 'TanviShah_CBC_Data_Request', effort_filename)) %>% clean_names()

AviList <- read_excel(file.path(curr_data_path,"raw_data", "Wauchope", "AviList-v2025.xlsx")) %>% clean_names()


```

## Initial Clean

```{r}

# CBC Initial Clean
CBCCounts <- cbc_data
names(CBCCounts) <- c("OID", "Abbrev", "Name", "Latitude", "Longitude", "Subnational_code", "Country_code", "Count_yr", "Cnt_dt", "COM_NAME", "SCI_NAME", "how_many", "TotalSpecies", "Editor_comment")

CBCCounts$Abbrev <- gsub('"', '', as.character(CBCCounts$Abbrev))
CBCCounts$Subnational_code <- gsub('"', '', as.character(CBCCounts$Subnational_code))
CBCCounts$Country_code <- gsub('"', '', as.character(CBCCounts$Country_code))
CBCCounts$Cnt_dt <- gsub('"', '', as.character(CBCCounts$Cnt_dt))
CBCCounts$COM_NAME <- gsub('"', '', as.character(CBCCounts$COM_NAME))
CBCCounts$Name <- gsub('"', '', as.character(CBCCounts$Name))
CBCCounts$SCI_NAME <- gsub('"', '', as.character(CBCCounts$SCI_NAME))

```

## Taxonomic Filtering

#### TS approach (CBC data only):

1\) Filter AviList for waterbird families of interest (stated in p. 3 of [Wauchope SI](https://static-content.springer.com/esm/art%3A10.1038%2Fs41586-022-04617-0/MediaObjects/41586_2022_4617_MOESM1_ESM.pdf))

2\) Eliminate entries with "sp."

3\) Save the exact matches

4\) Filter the edge cases, and save to master list

5\) Aggregate distinct entries given same genus species (and time, location)

```{r}

# waterbird families of interest
# directly from p. 3 of Wauchope SI
waterbird_families <- c(
  "Gaviidae", "Podicipedidae", "Pelecanidae", "Phalacrocoracidae", "Anhingidae",
  "Ardeidae", "Balaenicipitidae", "Scopidae", "Ciconiidae", "Threskiornithidae",
  "Phoenicopteridae", "Anhimidae", "Anatidae", "Pedionomidae", "Gruidae",
  "Aramidae", "Rallidae", "Heliornithidae", "Eurypygidae", "Jacanidae",
  "Rostratulidae", "Dromadidae", "Haematopodidae", "Ibidorhynchidae", 
  "Recurvirostridae", "Burhinidae", "Glareolidae", "Charadriidae", 
  "Scolopacidae", "Thinocoridae", "Laridae", "Rynchopidae")

# useful for debugging
alphabetized_waterbird_families <- sort(waterbird_families)
```

Step 0: Separate hybrid entries

```{r}
# want to save hybrids for imputation step
# enter 0 for years with no observation
# skip years where no observation besides hybrid

hybrids <- CBCCounts %>% filter(str_detect(SCI_NAME, " x "))
# separate hybrid names into two 

split_hybrids <- hybrids %>%
  separate(SCI_NAME, into = c("Hybrid1", "Hybrid2"), sep = " x ", fill = "right", remove = FALSE)

split_hybrids
# filter out non-waterbirds


```

Step 1: Filter AviList for Waterbird families of interest

```{r}

avi_f <- AviList %>% filter(family %in% alphabetized_waterbird_families )

matched_families <- intersect(alphabetized_waterbird_families, unique(AviList$family))
unmatched_families <- setdiff(alphabetized_waterbird_families, unique(AviList$family))
cat('Unmatched - Waterbird families that do not match between Avilist and CBC: ', unmatched_families, "\n", "\n")
cat('Matched - Waterbird families in Avilist that match with CBC: ', matched_families, "\n", "\n")

# total waterbird species in AviList
unique_sp_avi <- avi_f %>% filter(taxon_rank == "species")
cat('Number of unique species in AviList = ', nrow(unique_sp_avi), "\n","\n")
unique_sub_sp_avi <- avi_f %>% filter(taxon_rank == "subspecies")
cat("Number of unique subspecies in AviList = ", nrow(unique_sub_sp_avi))

```

Step 2 - Filter out CBC entries with "sp." -- will not find match to species

```{r}

CBCCounts_no_sp <- CBCCounts %>% filter(!str_detect(SCI_NAME, 'sp.'))
cat(nrow(CBCCounts) - nrow(CBCCounts_no_sp), " rows removed by filtering out sci names with sp.")
```

Step 3 - Keep CBC entries that have an exact genus species (or subspecies) match with waterbirds Avilist

```{r}
# 
# # save rows with sci name that match Avilist entries exactly 
# # of the form: "genus species" and "genus species subspecies"
CBC_exact_match <- CBCCounts_no_sp %>% filter(SCI_NAME %in% unique(avi_f$scientific_name))
# 
# # add family (waterbird) to CBC_exact_match dataset
CBC_exact_match$family <- avi_f$family[match(CBC_exact_match$SCI_NAME, avi_f$scientific_name)]

# number of unique species in CBC exact match
num_unique_sp_CBC <- length(unique(CBC_exact_match$SCI_NAME)) 
cat("Number of unique species in CBC exact match with AviList = ", num_unique_sp_CBC)

```

Step 4 - Deal with subspecies cases

```{r}

# Start with set exluded from prior step 
# Everything that doesn't fall under form: genus species and genus species subspecies
# This includes...
  # genus speciesA/speciesB --> exclude
  # genus species subspeciesA/subspeciesB --> include, later merge counts under "genus species"
  # genus species [subspecies group] --> include, later merge counts under "genus species"

# STEP 4A: 
# ... Start with excluded set
# ... Then separate genus, species, and subspecies
CBC_sub_sp_cases <- CBCCounts_no_sp %>% filter(!SCI_NAME %in% unique(avi_f$scientific_name)) %>% 
  separate(SCI_NAME, into = c("Genus", "Species", "Subspecies"), 
           sep = " ", fill = "right", extra = "drop", remove = FALSE)

# STEP 4B:
# ... Remove indeterminate species (containing slash in species)
CBC_sub_sp_clean <- CBC_sub_sp_cases %>%  filter(!str_detect(Species, "/"))

# STEP 4C:
# ... Rename indeterminate subspecies to simply "genus species"
CBC_sub_sp_filtered <- CBC_sub_sp_clean %>% mutate(SCI_NAME = str_c(word(SCI_NAME, 1), word(SCI_NAME, 2), sep = " "))


# Step 4D: 
# ... Select records of waterbirds from CBC edge cases
CBC_sub_sp_waterbird <- CBC_sub_sp_filtered %>% filter(SCI_NAME %in% unique(avi_f$scientific_name))
num_waterbird_sub_sp_cases <- length(unique(CBC_sub_sp_waterbird$SCI_NAME))
cat("Number of CBC subspecies records that are waterbirds = ", num_waterbird_sub_sp_cases, "\n","\n")

# STEP 4E:
# ... Change exact matches sci name to just "genus species"
# ... Reasoning: avi list includes some subspecies, so some CBC exact matches have
# ... subspecies. Ultimately want to merge counts based on genus species only
CBC_exact_match_mod <-CBC_exact_match  %>% 
  mutate(SCI_NAME = str_c(word(SCI_NAME, 1), word(SCI_NAME, 2), sep = " "))

# STEP 4F: 
# ... merge exact matches and edge cases 
CBC_total_match <- (bind_rows(CBC_exact_match_mod, CBC_sub_sp_waterbird) %>% arrange(SCI_NAME))

num_total_CBC_waterbirds <- length(unique(CBC_total_match$SCI_NAME))
cat("Total number of CBC entries that are waterbirds = ", num_total_CBC_waterbirds, "\n","\n" )

```

Step 5 - aggregate entries with same genus, species, date, location (subspecies should be counted under parent genus, species)

```{r}

CBC_unique_species <- CBC_total_match %>%
  dplyr::select(SCI_NAME, COM_NAME, family) %>%           # Keep only these two columns
  distinct(SCI_NAME, .keep_all = TRUE)   # Remove duplicate SCI_NAMEs


# aggregate based on Site and Year
CBC_aggregated <- CBC_total_match %>%
  group_by(Abbrev, Count_yr, SCI_NAME, Latitude, Longitude) %>%
  dplyr::summarise(total_count = sum(how_many, na.rm = TRUE))

# CBC_aggregated <- CBC_aggregated %>% mutate(HybridFlag = 0)
```

Handle Hybrids

```{r}

# filter for waterbird hybrids by splitting hybrid name and checking both against avi list
hybrids_keep <- split_hybrids %>% filter(Hybrid1 %in% unique(avi_f$scientific_name) | Hybrid2 %in% unique(avi_f$scientific_name))

# aggregate filtered hybrid entries by site, year, and name
hybrids_aggregated <- hybrids_keep %>%
  group_by(Abbrev, Count_yr, SCI_NAME) %>%
  dplyr::summarise(total_count = sum(how_many, na.rm = TRUE))

hybrids_aggregated <- hybrids_aggregated %>% mutate(HybridFlag = 1)

# count number of hybrids vs totals
per_hyb <- round(nrow(hybrids_aggregated) / (nrow(CBC_aggregated)+nrow(hybrids_aggregated)) * 100, 5)
num_hyb <- nrow(hybrids_aggregated)
num_non_hyb <- nrow(CBC_aggregated)



df_nums <- data.frame(
  count =  c(num_hyb, num_total, per_hyb),
  dataset = c("hybrids", "non_hybrids", "percent of hybrids")
)

kable(df_nums, caption = "Hybrids are a small fraction of overall dataset. Removing from dataset before Impute step") %>%
  kable_styling()
# add hybrids back into full dataset 
# create "hybrid flag" to keep track of hybrids and non-hybrids (remove hybrids for analysis)

BirdCounts <- CBC_aggregated
```

## Zero Impute - HW code

```{r}
# 
# BirdCounts <- rbind(CBCCounts, IWCCounts, fill=TRUE)
# 
# BirdCountsZeroImpute <- rbindlist(pbmclapply(unique(BirdCounts$SiteCode), function(x){
#   SiteCounts <- subset(BirdCounts, SiteCode==x & HybridFlag==0)
#   SiteCounts$ImputeFlag <- 0
#   SiteYears <- unique(SiteCounts$Year)
#   SiteSpecies <- unique(SiteCounts$Species)
#   SiteHybrids <- subset(BirdCounts, SiteCode==x & HybridFlag==1)
#   SiteHybridsSpecies <- unique(SiteHybrids[,c("HybridLevel", "HybridValue", "Year")])
#   ZeroesSiteSpecies <- rbindlist(lapply(SiteSpecies, function(y){
#     SiteSpeciesCounts <- subset(SiteCounts, HybridFlag==0 & Species==y)
#     HybridMatch <- SiteHybridsSpecies[SiteHybridsSpecies$HybridValue %in% c(unique(SiteSpeciesCounts$Genus), unique(SiteSpeciesCounts$Family), unique(SiteSpeciesCounts$Order), unique(SiteSpeciesCounts$Class))]
#     ZeroYears <- SiteYears[!SiteYears %in% unique(c(SiteSpeciesCounts$Year, HybridMatch$Year))]
#     ZeroCounts <- do.call("rbind", replicate(length(ZeroYears), SiteSpeciesCounts[1,], simplify = FALSE))
#     if(is.null(ZeroCounts)){
#       return(SiteSpeciesCounts)
#     }
#     ZeroCounts$Count <- 0
#     ZeroCounts$Year <- ZeroYears
#     ZeroCounts$ImputeFlag <- 1
#     SiteSpeciesCounts <- rbind(SiteSpeciesCounts, ZeroCounts)
#     return(SiteSpeciesCounts)
#   }))
#   write.csv(ZeroesSiteSpecies, paste0(DataFP, "WaterbirdData_2020/ZeroImputedSites/Site", x, ".csv"), row.names=FALSE)
#   return(ZeroesSiteSpecies)
# }, mc.cores=6))
# 
# #Some sites are lost, but only those without any counted species (either only hybrids, or only negative obs)
# BirdCountsZeroImpute <- rbindlist(pblapply(list.files(path=paste0(DataFP, "WaterbirdData_2020/ZeroImputedSites/"), pattern="*.csv", full.names = TRUE), function(x) fread(x)), fill=TRUE)
# BirdCountsZeroImpute[,c("HybridFlag", "HybridLevel", "HybridValue")] <- NULL
# 
# write.csv(BirdCountsZeroImpute, paste0(DataFP, "WaterbirdData_2020/BirdCounts.csv"), row.names=FALSE)
# 

```

## Zero Impute

```{r}

CBC_aggregated <- CBC_aggregated %>% clean_names()

# parse unique location variables
unique_loc <- CBC_aggregated %>% distinct(abbrev)
unique_lat_long <- CBC_aggregated %>% distinct(latitude, longitude)
unique_lat <- unique(CBC_aggregated$latitude)
unique_long <- unique(CBC_aggregated$longitude)

df_loc <- data.frame(
  category = c("unique locations", "unique abbrevs", "unique lat long pairs", "unique lats", "unique longs"),
  count = c(nrow(unique_loc), length(unique_abbrev), nrow(unique_lat_long), length(unique_lat), length(unique_long))
)
kable(df_loc)


# ultimately, just group by site  (Abbreviation) since lat and long seem to have some kind of drift
unique_abbrev <- unique(CBC_aggregated$abbrev)
CBC_unique_species <- unique(CBC_aggregated$sci_name)
unique_years <- unique(CBC_aggregated$count_yr)

# need ungroup df prior to join
CBC_aggregated <- CBC_aggregated %>% ungroup()

# create a dataframe of timeseries, for each species and site 
CBC_perms <- expand.grid(
  sci_name = CBC_unique_species, 
  count_yr = unique_years, 
  abbrev = unique_abbrev)

# remove lat and long from CBC_aggregate since the Abbrev alone is enough
CBC_pre_join <- CBC_aggregated%>% ungroup() %>% dplyr::select(-latitude, -longitude)

# left join to fill in gaps in time series with 0
CBC_zero_impute <- CBC_perms %>%
  left_join(CBC_pre_join, 
            by = c("abbrev", "count_yr", "sci_name" ))

```

## Get Effort

```{r}

#Get Effort
CBCEffort <- effort_data
names(CBCEffort) <- c("OID", "Abbrev", "Name", "Count_yr", "Country_code", "Description", "Distance","Distance_unit", "Hours")

#Distance and hours are correlated - convert to numeric, remove NA's
CBCEffort$Distance <- as.numeric(CBCEffort$Distance)
CBCEffort$Hours <- as.numeric(CBCEffort$Hours)
CBCEffort <- CBCEffort[complete.cases(CBCEffort$Hours),]
CBCEffort <- CBCEffort[complete.cases(CBCEffort$Distance),]

# Quick Bootstrap simulation for visualization
CBCEffortThou <- CBCEffort[sample(1:nrow(CBCEffort), 1000, replace=TRUE),]
plot(CBCEffortThou$Hours, CBCEffortThou$Distance)

#Remove distance and zero count hours
CBCEffort[,c("Distance", "Units", "Method", "Name", "Country_code")] <- NULL
CBCEffort2 <- subset(CBCEffort, Hours!=0)


 CBCEffort2 <- CBCEffort %>%
   dplyr::group_by(Abbrev, Count_yr) %>%
   dplyr::summarise(
     Hours = sum(Hours, na.rm = TRUE),
     Abbrev = first(Abbrev),
     Count_yr = first(Count_yr)
   )

Check <- dcast(CBCEffort2, Abbrev + Count_yr~., length, value.var="Hours")
if(max(unique(Check$.))!=1){stop("There are still cases of double hours!")}


CBCCounts_original <- CBCCounts # redundant, keeping for now...
# CBCCounts_premerge <- CBCCounts  %>% dplyr::select(-c(OID, Abbrev))

CBCEffort2$SiteYear <- paste0(CBCEffort2$Abbrev,"_", CBCEffort2$Count_yr)
CBCEffort2[,c("Abbrev", "Count_yr")] <- NULL

BirdCounts2 <- BirdCounts
BirdCounts2$SiteYear <- paste0(BirdCounts$Abbrev,"_", BirdCounts$Count_yr)

CBCCounts <- merge(BirdCounts2, CBCEffort2, by="SiteYear")
#Now sort out dates
CBCCounts[,c("Year", "Month", "Day")] <- as.data.frame(str_split_fixed(CBCCounts$Cnt_dt, "[-]", 3))
CBCCounts$Month <- as.numeric(as.character(CBCCounts$Month))
CBCCounts$Month[is.na(CBCCounts$Month)] <- 0
CBCCounts <- subset(CBCCounts, Month!=3) #Remove march counts (only Dec, Jan, Feb)

CBCCounts$Year <- 1900+CBCCounts$Count_yr

CBCCounts$Day <- as.numeric(as.character(CBCCounts$Day))
CBCCounts$Day[is.na(CBCCounts$Day)] <- 0

CBCCounts[,c("Count_yr", "Cnt_dt")] <- NULL

#Now sort out double counts (sum by days counted, then mean by year)
CBCCounts$SiteSpecYear <- paste0(CBCCounts$Abbrev, "_", CBCCounts$Species, "_", CBCCounts$Year)

CBCCounts[,c("SiteSpecYear", "SiteYear")] <- NULL

#Remove multiple sites at the site coordinate:
CBCCounts$Latitude <- round(CBCCounts$Latitude, 4)
CBCCounts$Longitude <- round(CBCCounts$Longitude, 4)

CBCCounts$Coordinates <- paste0(CBCCounts$Latitude, "_", CBCCounts$Longitude)
CBCCountsCast <- dcast(unique(CBCCounts[,c("Coordinates", "Abbrev")]), Coordinates~., length, value.var="Abbrev")

CBCCounts <- CBCCounts[CBCCounts$Coordinates %in% subset(CBCCountsCast, .==1)$Coordinates,]
CBCCounts$Coordinates <- NULL

#Check on a map
# Map(unique(CBCCounts[,c("Latitude", "Longitude", "Abbrev")]))

# 
# write.csv(CBCCounts, file.path(baci_home_dir, "data", "output", "Wauchope", 'BirdCounts.csv'), row.names = FALSE)
# 


```
