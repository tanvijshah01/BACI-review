---
title: "Wauchope_2_ExtractCovariates_TS"
format: html
editor: visual
author: Tanvi Shah
---

This script aims to replicate Step 2 of Wauchope's Analysis in the original file 2_ExtractCovariates.R:

Takes the data cleaned in Script 1 and extracts site and species specific covariates: migrant status, climatic variables, landuse and human population variables, governance values, distance to nearest city, slope and surface water

## Load Libraries

```{r}
  library(data.table)
  library(pbapply)
  library(pbmcapply)
  library(dplyr)
  # library(rgdal) - no longer exists
  # library(rgeos) - no longer exists
  library(ncdf4)
  # library(chron) - no longer exists
  library(raster)
  # library(rlist)
  library(stringr)
  library(tidyverse)
  library(abind)
  library(plyr)
  ## raster snapping libraries (in place of QGIS)
  library(raster)
  library(sp)
  library(rgeos)
  library(sf)
  # library(ClusterR)
```

## Data Sources

1\) Climate

-   <https://data.ceda.ac.uk/badc/cru/data/cru_ts/cru_ts_4.09/data>

-   download temperature and precipitation

2\) Fertilizer

-   <https://essd.copernicus.org/articles/9/181/2017/essd-9-181-2017-assets.html>

3\) Landuse

-   <https://archaeology.datastations.nl/dataset.xhtml?persistentId=doi:10.17026/DANS-25G-GEZ3>

4\) Species Distribution Polygons

-   <https://datazone.birdlife.org/contact-us/request-our-data> (Data request form - choose species distribution maps)

5\)

6\)

## Define Data Directory

```{r}
library(terra)
# get current directory, make sure project is open 
baci_home_dir <-here::here()
# navigate to data directory
curr_data_path <- file.path(baci_home_dir, 'data')

birdcounts <- read_csv(file.path(curr_data_path, 'output', 'Wauchope', 'BirdCounts.csv'))

# Read vector data
BirdPolygons <- vect(b_path)


library(sf)
b_path <- file.path(curr_data_path,'raw_data', 'Wauchope',"BOTW_2025.gpkg")
BirdPolygons <- st_read(b_path)
BirdPolygons <- as(BirdPolygons, "Spatial")  # 

```

## Define Coordinate Reference Systems

```{r}
WGSCRS <- CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")
MollCRS <- CRS("+proj=moll +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +units=m +no_defs")
```

## Snap Functions

Snap site to nearest raster cell of each covariate

```{r}



WGSCRS <- CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")
MollCRS <- CRS("+proj=moll +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +units=m +no_defs")

SnapPoints_12_in_R <- function(Variable, TemplateFunction, WaterbirdCounts){
  
  # Create template raster with unique values for each cell
  Template <- TemplateFunction
  Template[!is.na(Template)] <- 1:length(Template[!is.na(Template)])
  crs(Template) <- WGSCRS
  writeRaster(Template, file=paste0(DataFP, "WaterbirdData_2020/Covariates/Snap/", Variable, "/Template.tif"), 
              format="GTiff", overwrite=TRUE)
  
  # Make a points file of sites
  Sites <- unique(WaterbirdCounts[,c("SiteCode", "Latitude", "Longitude")])
  SitesPoints <- cbind(Sites$Longitude, Sites$Latitude)
  SitesPoints <- SpatialPointsDataFrame(SitesPoints, Sites, proj4string = WGSCRS)
  
  # Find which points don't overlap with raster
  RasterExtract <- as.vector(raster::extract(Template, SitesPoints, method="simple"))
  Sites$Polygon <- RasterExtract
  SitesNA <- Sites[is.na(Sites$Polygon),]
  
  # If all points overlap, we're done
  if(nrow(SitesNA) == 0){
    Sites$Longitude <- Sites$Longitude  # Keep original coords
    Sites$Latitude <- Sites$Latitude
    Sites$Polygon <- NULL
    names(Sites) <- c("SiteCode", paste0("Lat", Variable), paste0("Lon", Variable))
    return(Sites)
  }
  
  # For points that don't overlap, snap to nearest cell
  print(paste0("Snapping ", nrow(SitesNA), " points to nearest raster cells..."))
  
  # Project template to Mollweide
  TemplateMoll <- projectRaster(Template, crs=MollCRS, method="ngb")
  
  # Convert raster to polygons in Mollweide projection
  TemplatePolygons <- rasterToPolygons(TemplateMoll, dissolve=FALSE)
  names(TemplatePolygons) <- "UniqueValue"
  
  # Project NA sites to Mollweide
  SitesNASHP <- SpatialPointsDataFrame(
    cbind(SitesNA$Longitude, SitesNA$Latitude), 
    SitesNA, 
    proj4string = WGSCRS
  )
  SitesNASHPMoll <- spTransform(SitesNASHP, MollCRS)
  
  # Find nearest polygon for each point
  NearestResults <- data.frame(
    SiteCode = character(nrow(SitesNA)),
    join_UniqueValue = numeric(nrow(SitesNA)),
    distance = numeric(nrow(SitesNA)),
    stringsAsFactors = FALSE
  )
  
  for(i in 1:nrow(SitesNASHPMoll)){
    # Calculate distance to all polygons
    distances <- gDistance(SitesNASHPMoll[i,], TemplatePolygons, byid=TRUE)
    
    # Find nearest
    nearest_idx <- which.min(distances)
    
    NearestResults$SiteCode[i] <- as.character(SitesNASHPMoll$SiteCode[i])
    NearestResults$join_UniqueValue[i] <- TemplatePolygons$UniqueValue[nearest_idx]
    NearestResults$distance[i] <- min(distances)
  }
  
  # Get coordinates of the nearest cells (back in WGS84)
  TemplatePoints <- as.data.frame(rasterToPoints(Template))
  names(TemplatePoints) <- c("Longitude", "Latitude", "UniqueValue")
  
  # Merge to get snapped coordinates
  NAPointsSnap <- merge(NearestResults, TemplatePoints, 
                        by.x="join_UniqueValue", by.y="UniqueValue")
  
  # Filter to points within 50km
  NAPointsSnapCut <- subset(NAPointsSnap, distance < 50000)
  NAPointsSnapCut <- NAPointsSnapCut[, c("SiteCode", "Latitude", "Longitude")]
  
  print(paste0("Snapped ", nrow(NAPointsSnapCut), " points within 50km. ",
               nrow(SitesNA) - nrow(NAPointsSnapCut), " points were >50km from nearest cell and excluded."))
  
  # Combine with sites that did overlap
  Sites$Polygon <- NULL
  SitesOverlap <- Sites[!Sites$SiteCode %in% SitesNA$SiteCode, ]
  SitesFinal <- rbind(SitesOverlap, NAPointsSnapCut)
  
  names(SitesFinal) <- c("SiteCode", paste0("Lat", Variable), paste0("Lon", Variable))
  
  # Merge with original data
  WaterbirdCounts <- merge(WaterbirdCounts, SitesFinal, by="SiteCode")
  
  return(WaterbirdCounts)
}


```

## Initial Clean

```{r}
#### Initial Clean + Migratory Status ####
BirdCounts <- fread(paste0(DataFP, "WaterbirdData_2020/BirdCounts.csv"))
BirdCounts[,c("V1", "SubnationalCode", "CountryCode", "IWCCountry")] <- NULL

```
